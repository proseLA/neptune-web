import { DocLink } from '../../../utils/pageUtils';

Neptune-css and Neptune-components are ready to use in RTL (Right to Left) direction languages. 

## The basics

Get <code>dir</code> attribute in HTML element depending the language.

LTR laguages:
```
<html dir="ltr" >
```

RTL laguages:
```
<html dir="rtl" >
```

- <code>dir</code> attribute has implicit the direction CSS property natively, so using the attribute is enough to make the layout switch.
- Default alignment, tables, flex and grid elements work really nice with the direction property and the browser creates natively the expected layout, except when the code uses a "left" or a "right" value.
- W3C specification is working on [logical properties and values](https://drafts.csswg.org/css-logical/) to solve the horizontal physical direction but the support is being uneven yet.
- To solve the horizontal properties and values we are going to use the RTL mixin. Neptune code is prepared with the RTL mixin already, but you may add it to your custom CSS in your project, to have the total experience.

## The RTL mixin
There is Less [a mixin](https://github.com/transferwise/neptune-web/blob/rtl-with-css-logical-properties/packages/css/src/less/mixins/_logical-properties-IE-friendly.less) to control the direction of the physical horizontal properties and values in Neptune. With this mixin we are going to be able to control and scale the support in browsers of logical properties. Right now itâ€™s prepared to output the IE11 friendly version.

### Usage

Add the import reference at the top of the .less file:

```
@import (reference)
  "@transferwise/neptune-css/src/less/mixins/_logical-properties.less";
```

Update all the horizontal properties (left, right) with a mixin call in your custom .less file:

ðŸ’¡ Tip: If left and right values are equal in the same selector we can keep them as they are without having to update to the mixin syntax. 
Keep the code as it is when:
```
padding-left: var(--foo1);
padding-right: var(--foo1);
```
```
padding: 0 var(--foo);
```
```
padding: 0 var(--foo) 0;
```

### New syntax:


<h4 className="m-t-1">Spacing:</h4>

```
margin-left: var(--foo); â†’ .margin(left, var(--foo));
```
The output of above code is: 
```
Default or LTR â†’ margin-left: var(--foo);
RTL â†’ margin-right: var(--foo); margin-left: 0;
```
The original margin resets to the initial value. If that value is not 0 or initial, there is a second optional value (`value2` in the next example) for the mixin `.margin(direction, value1, value2)` which you can use if you need to specify a different value for the opposite direction.

For instance, let's imagine that you have a `margin-left: 8px` in your code that you want to transform into a RTL friendly property. The mixin for it would be `.margin(left, 8px)`, and in RTL cases it would be transformed into `margin-right: 8px; margin-left: 0;`.
You might want to change the `0` to a different value. If you do, you can provide the optional second value (the third parameter below):
```
.margin(left, var(--foo), var(--bar));
```

We use this logic because we want to keep the default direction property with not conditional selectors in the mixin which could add specificity to the property and create collateral cascade collisions in consumers code.


```
padding-left: var(--foo); â†’ .padding(left, var(--foo));
```
Same as in margin cases, in padding you also have this second value to change the original direction value if needed `.padding(direction, value1, value2)`

Shorthands (only when left != right or you need more specificity):
```
margin: 0 0 0 var(--foo); â†’ .margin-shorthand(0, 0, 0, var(--foo));
```
```
padding: 0 0 0 var(--foo); â†’ .padding-shorthand(0, 0, 0, var(--foo));
```

#### Alignment:

```
text-align: left; â†’ .text-align(left);
```

#### Positions: 

```
left: var(foo);. â†’ .left(var(--foo));
```
For positions you also have this second value to change the original direction value from initial to another value if needed: `.left(value1, value2)`

#### Floats:

```
float: left;. â†’ .float(left);
```

#### Clear:

```
clear: left â†’ .clear(left);
```

#### Border: 

```
border-left: 1px solid pink; â†’ .border(left, 1px, solid, pink);
```
```
border-left-width: 1px; â†’ .border-width(left, 1px);
```
```
border-top-left-radius: 3px; â†’ .border-top-dir-radius(left, 3px);
```
```
border-bottom-left-radius: 3px; â†’ .border-bottom-dir-radius(left, 3px);
```
```
border-bottom-left-radius: 3px;
border-top-left-radius: 3px; (both top and bottom) â†’ .border-radius(left, 3px); 
```

#### Background position: 

```
background-position: left; â†’  .background-position(left);
```
```
background-position: left bottom; â†’  .background-position(left, bottom);
```

#### Background linear gradient: 

```
background: linear-gradient(to left, var(--color1) var(--color2)) â†’ .background-linear-gradient(left, var(--color1), var(--color2));
```

#### Horizontal translations
```
transform: translateX(var(--foo)); â†’ .translateX(var(--foo));
```

export const meta = {
  name: 'RTL layout',
};
